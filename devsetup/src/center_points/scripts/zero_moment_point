#!/usr/bin/env python
# -*- encoding: utf-8 -*-

import rospy, sys, argparse, os
from typing import Union, List
import numpy as np
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from urdf_parser_py.urdf import URDF
import tf2_ros, tf2_geometry_msgs
from sensor_msgs.msg import Imu, JointState
from geometry_msgs.msg import (
    WrenchStamped, Wrench,
    PointStamped, Point,
    TransformStamped,
    Vector3, Vector3Stamped)

from center_points.utils import PointCommunicator, Point_to_numpy, numpy_to_Point, Vector3_to_numpy, numpy_to_Vector3, Vector3Stamped_to_PointStamped, urdf_link_map # type: ignore

g = 9.181 # m/sÂ²

@dataclass
class CalcData:
    linear_a : np.ndarray = np.zeros(3)
    angular_v : np.ndarray = np.zeros(3)
    com : np.ndarray = np.zeros(3) # in odom
    stamp : rospy.Time = rospy.Time(0)
    joint_names : List[str] = field(default_factory=list)
    joint_velocities : List[float] = field(default_factory=list)
    joint_accelerations : List[np.ndarray] = field(default_factory=list)
    link_masses : List[float] = field(default_factory=list)
    link_coordinates : List[np.ndarray] = field(default_factory=list) # in odm

class ZMP_Calculator(ABC):
    @abstractmethod
    def __init__(self, frame : str = 'base_link'):
        self.frame = frame
        self.buffer = tf2_ros.Buffer()
        self._listener = tf2_ros.TransformListener(self.buffer)
    @abstractmethod
    def gather_data(self) -> CalcData:
        return CalcData()
    @abstractmethod
    def calc(self, data : CalcData) -> np.ndarray:
        return np.array([])
    
class ZMP_Calc_Point(ZMP_Calculator):
    def __init__(self, frame = 'base_link'):
        super().__init__(frame)
    def gather_data(self) -> CalcData:
        imu = rospy.wait_for_message('/base_imu', Imu)
        if imu is None:
            return CalcData()
        angular_v = Vector3_to_numpy(imu.angular_velocity)
        linear_a = Vector3_to_numpy(imu.linear_acceleration)
        com = rospy.wait_for_message('/com_pub', PointStamped)
        if com is None:
            return CalcData()
        if not self.buffer.can_transform(self.frame, com.header.frame_id, com.header.stamp):
            return CalcData()
        com_frame = self.buffer.transform(com, self.frame)
        data = CalcData(
            linear_a=linear_a,
            angular_v=angular_v,
            com=Point_to_numpy(com_frame.point),
            stamp=rospy.Time())
        return data
    def calc(self, data : CalcData) -> np.ndarray:
        com = data.com
        linear_a = data.linear_a
        # compute zmp
        px = com[0] - (com[2] * linear_a[0]) / (linear_a[2] + g)
        py = com[1] - (com[2] * linear_a[1]) / (linear_a[2] + g)
        return np.array([px, py, 0])
    
class ZMP_Calc_Linear(ZMP_Calculator):
    def __init__(self, frame = 'base_link'):
        super().__init__(frame)
    def gather_data(self) -> CalcData:
        joint_states0 = rospy.wait_for_message('/joint_states', JointState)
        joint_states1 = rospy.wait_for_message('/joint_states', JointState)
        if joint_states0 is None or joint_states1 is None:
            return CalcData()
        data = CalcData()
        data.joint_names = joint_states0.name
        velocities : np.ndarray = (np.array(joint_states0.velocity) + np.array(joint_states1.velocity)) * 0.5
        data.joint_velocities = velocities.tolist()
        if len(data.joint_names) != len(data.joint_velocities):
            return CalcData()
        if len(data.joint_names) == 0:
            return CalcData()
        
        # approx acceleration
        t0 : int = joint_states0.header.stamp.to_nsec()
        t1 : int = joint_states1.header.stamp.to_nsec()
        for i in range(len(joint_states0.velocity)):
            v0 = joint_states0.velocity[i]
            v1 = joint_states1.velocity[i]
            a = (Point_to_numpy(v1) - Point_to_numpy(v0))*1000.0 / (t1 - t0)
            data.joint_accelerations.append(a)

        # get static info (mass, link com)
        stamp_nsecs = (joint_states0.header.stamp.to_nsec() + joint_states1.header.stamp.to_nsec()) / 2
        data.stamp = rospy.Time(nsecs=stamp_nsecs)
        link_dict : dict = urdf_link_map()
        for joint_name in data.joint_names:
            link_name = str.replace(joint_name, 'joint', 'link')
            # mass
            if link_name in link_dict.keys():
                m : float = link_dict[link_name].inertial.mass
            else:
                m = 0.0
            data.link_masses.append(m)
            # link com (in odm)
            if not self.buffer.can_transform('odom', link_name, data.stamp):
                data.link_coordinates.append(np.zeros(3))
                continue
            local_link_com = PointStamped()
            local_link_com.header.stamp = data.stamp
            local_link_com.header.frame_id = link_name
            local_link_com.point = Point(0,0,0)
            link_com = self.buffer.transform(local_link_com, 'odom')
            data.link_coordinates.append(link_com)
        # com
        # com_stamped = rospy.wait_for_message('/com_pub', PointStamped)
        # if not com_stamped is None:
        #     data.com = Point_to_numpy(com_stamped.point)
        # else:
        #     data.com = np.zeros(3)

        return data
    def calc(self, data : CalcData) -> np.ndarray:
        px_num = 0.0
        px_den = 0.0
        py_num = 0.0
        py_den = 0.0
        for i in range(len(data.joint_names)):
            m = data.link_masses[i]
            x = data.link_coordinates[i][0]
            y = data.link_coordinates[i][2]
            z = data.link_coordinates[i][1]
            ddx = 0.0
            ddy = 0.0
            ddz = 0.0

            px_num = m*((ddz+g)*x-z*ddx)
            px_den = m*(ddz+g)

            py_num = m*((ddz+g)*y-z*ddy)
            py_den = m*(ddz+g)
            
        px = px_num / px_den
        py = py_num / py_den
        return np.array([px, py, 0.0])
    
class ZMP_Calc_Full(ZMP_Calculator):
    def __init__(self, frame = 'base_link'):
        super().__init__(frame)
        rospy.logerr_once('This mode is not implemented yet!')
    def gather_data(self) -> CalcData:
        return CalcData()
    def calc(self, data : CalcData) -> np.ndarray:
        return np.array([0,0,0])

def main(args):
    mode = args.mode
    rospy.init_node('zero_moment_point', anonymous=False)
    zmp_communicator = PointCommunicator('zmp_'+mode, frame='odom')
    zmp_calcer = None
    if mode == 'point':
        zmp_calcer = ZMP_Calc_Point(zmp_communicator.frame)
    elif mode == 'linear':
        zmp_calcer = ZMP_Calc_Linear(zmp_communicator.frame)
    elif mode == 'full':
        pass
    if zmp_calcer is None:
        rospy.logerr('No Mode was selected. Choose between: full, linear or point')
        return -1
    rospy.loginfo_once('Created ZMP Calculator of type '+str(type(zmp_calcer)))
    
    while not rospy.is_shutdown():
        data0 : CalcData = zmp_calcer.gather_data()
        zmp : np.ndarray = zmp_calcer.calc(data0)
        zmp_communicator.publish_point(zmp)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--mode', type=str, help='full, linear, point', default='point')
    args = parser.parse_args()
    main(args)