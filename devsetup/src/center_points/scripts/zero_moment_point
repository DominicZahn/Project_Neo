#!/usr/bin/env python
# -*- encoding: utf-8 -*-

import rospy, sys, argparse, os
from typing import Union, List
import numpy as np
from abc import ABC, abstractmethod
from dataclasses import dataclass
from urdf_parser_py.urdf import URDF
import tf2_ros, tf2_geometry_msgs
from sensor_msgs.msg import Imu, JointState
from geometry_msgs.msg import (
    WrenchStamped, Wrench,
    PointStamped, Point,
    TransformStamped,
    Vector3, Vector3Stamped)

from center_points.utils import PointCommunicator, Point_to_numpy, numpy_to_Point, Vector3_to_numpy, numpy_to_Vector3, Vector3Stamped_to_PointStamped, urdf_link_map # type: ignore

@dataclass
class CalcData:
    linear_a : np.ndarray = np.zeros(3)
    angular_v : np.ndarray = np.zeros(3)
    com : np.ndarray = np.zeros(3) # in odom
    stamp : rospy.Time = rospy.Time(0)

class ZMP_Calculator(ABC):
    @abstractmethod
    def __init__(self, frame : str = 'base_link'):
        self.frame = frame
        self.buffer = tf2_ros.Buffer()
        self._listener = tf2_ros.TransformListener(self.buffer)
    @abstractmethod
    def gather_data(self) -> CalcData:
        return CalcData()
    @abstractmethod
    def calc(self, data_list : List[CalcData]) -> np.ndarray:
        return np.array([])
    
class ZMP_Calc_Point(ZMP_Calculator):
    def __init__(self, frame = 'base_link'):
        super().__init__(frame)
    def gather_data(self) -> CalcData:
        imu = rospy.wait_for_message('/base_imu', Imu)
        if imu is None:
            return CalcData()
        angular_v = Vector3_to_numpy(imu.angular_velocity)
        linear_a = Vector3_to_numpy(imu.linear_acceleration)
        com = rospy.wait_for_message('/center_of_mass_pub', PointStamped)
        if com is None:
            return CalcData()
        if not self.buffer.can_transform(self.frame, com.header.frame_id, rospy.Time()):
            return CalcData()
        com_frame = self.buffer.transform(com, self.frame)
        data = CalcData(
            linear_a=linear_a,
            angular_v=angular_v,
            com=Point_to_numpy(com_frame.point),
            stamp=rospy.Time())
        return data
    def calc(self, data_list : List[CalcData]) -> np.ndarray:
        com = data_list[0].com
        linear_a = data_list[0].linear_a
        # compute zmp
        g = 9.181 # m/sÂ²
        px = com[0] - (com[2] * linear_a[0]) / (linear_a[2] + g)
        py = com[1] - (com[2] * linear_a[1]) / (linear_a[2] + g)
        return np.array([px, py, 0])
    
class ZMP_Calc_Linear(ZMP_Calculator):
    def __init__(self, frame = 'base_link'):
        super().__init__(frame)
        rospy.logerr_once('This mode is not implemented yet!')
    def gather_data(self) -> CalcData:
        return CalcData()
    def calc(self, data_list : List[CalcData]) -> np.ndarray:
        return np.array([0,0,0])
    
class ZMP_Calc_Full(ZMP_Calculator):
    def __init__(self, frame = 'base_link'):
        super().__init__(frame)
        rospy.logerr_once('This mode is not implemented yet!')
    def gather_data(self) -> CalcData:
        return CalcData()
    def calc(self, data_list : List[CalcData]) -> np.ndarray:
        return np.array([0,0,0])

def main(args):
    mode = args.mode
    rospy.init_node('zero_moment_point', anonymous=False)
    zmp_communicator = PointCommunicator('zmp_'+mode, frame='odom')
    zmp_calcer = None
    if mode == 'point':
        zmp_calcer = ZMP_Calc_Point(zmp_communicator.frame)
    elif mode == 'linear':
        pass
    elif mode == 'full':
        pass
    if zmp_calcer is None:
        rospy.logerr('No Mode was selected. Choose between: full, linear or point')
        return -1
    rospy.loginfo_once('Created ZMP Calculator of type '+str(type(zmp_calcer)))
    
    while not rospy.is_shutdown():
        data0 : CalcData = zmp_calcer.gather_data()
        data1 : CalcData = zmp_calcer.gather_data()
        zmp : np.ndarray = zmp_calcer.calc([data0, data1])
        zmp_communicator.publish_point(zmp)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--mode', type=str, help='full, linear, point', default='point')
    args = parser.parse_args()
    main(args)
